# FinScenarioMap

A full-stack financial scenario mapping application that ingests risk scenarios, matches them against a historical case corpus using vector similarity or TF-IDF, and generates actionable recommendations using a Groq LLM. Built with FastAPI, React, PostgreSQL, and ChromaDB — containerised with Docker and deployed on AWS EC2.

---

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Tech Stack](#tech-stack)
- [Key Features](#key-features)
- [AI & Matching Pipeline](#ai--matching-pipeline)
- [Security](#security)
- [API Reference](#api-reference)
- [Project Structure](#project-structure)
- [Local Development](#local-development)
- [Deployment](#deployment)
- [Demo Credentials](#demo-credentials)

---

## Overview

FinScenarioMap helps financial risk teams submit and analyse scenarios (Market, Credit, Liquidity, Operational, Fraud). For each scenario, the system:

1. Validates and normalises the input
2. Finds the top 5 most similar historical cases from a 63-case corpus
3. Generates 3–6 actionable risk recommendations via Groq LLM
4. Persists results to PostgreSQL with full audit logging
5. Optionally stores uploaded files in AWS S3

---

## Architecture

```
┌─────────────────────────────────────────────────────┐
│                   React Frontend                     │
│         (Vite, TypeScript, served by FastAPI)        │
└─────────────────┬───────────────────────────────────┘
                  │ HTTP / REST (same origin)
┌─────────────────▼───────────────────────────────────┐
│              FastAPI Backend (Python 3.11)            │
│                                                      │
│  ┌─────────────┐   ┌──────────────┐  ┌───────────┐  │
│  │  LangGraph  │   │  Historical  │  │   Groq    │  │
│  │  Workflow   │──▶│   Matcher    │  │    LLM    │  │
│  │  (2 nodes)  │   │ (3-tier AI)  │  │   (Recs)  │  │
│  └─────────────┘   └──────┬───────┘  └───────────┘  │
│                           │                          │
│              ┌────────────▼──────────┐               │
│              │  ChromaDB  │  TF-IDF  │               │
│              │  (vector)  │(fallback)│               │
│              └────────────────────── ┘               │
└───────────┬──────────────────────────────────────────┘
            │
┌───────────▼──────────┐    ┌─────────────┐
│   PostgreSQL (DB)     │    │   AWS S3    │
│  scenarios, audit,    │    │  (uploads)  │
│  reference cases      │    └─────────────┘
└───────────────────────┘
```

**Deployment:** Single Docker image (multi-stage build) on AWS EC2. Backend serves both the REST API and the compiled React frontend from the same origin (port 8000) — no CORS issues, no separate frontend server.

---

## Tech Stack

| Layer | Technology |
|---|---|
| **Frontend** | React 18, TypeScript, Vite |
| **Backend** | Python 3.11, FastAPI, Uvicorn |
| **AI / LLM** | Groq API (`llama-3.1-8b-instant`) |
| **Embeddings** | Groq (`nomic-embed-text-v1_5`) → HuggingFace (`all-MiniLM-L6-v2`) → TF-IDF |
| **Vector Store** | ChromaDB (persistent, cosine similarity) |
| **Workflow** | LangGraph (directed graph, 2 nodes) |
| **Database** | PostgreSQL 15 (psycopg2) |
| **Auth** | JWT (PyJWT, HS256), RBAC (user / admin) |
| **Encryption** | AES-256-GCM at rest (cryptography), TLS in transit |
| **File Storage** | AWS S3 (boto3) |
| **Containerisation** | Docker, Docker Compose |
| **Cloud** | AWS EC2, EBS |

---

## Key Features

- **Scenario input** — form or bulk CSV/JSON upload (up to 5 MB)
- **3-tier historical matching** — Groq embeddings → HuggingFace → TF-IDF fallback, always returns top 5 cases
- **AI recommendations** — 3–6 actionable controls generated by Groq LLM per scenario
- **Vector store** — ChromaDB with cosine similarity; synced at startup from 63 reference cases + user submissions
- **Dashboard** — recent submissions, historical cases browser, audit log viewer
- **RBAC** — `user` role for scenario submission; `admin` role for audit logs
- **Audit logging** — every login, scenario create, and upload is logged to PostgreSQL
- **Encryption at rest** — `input_description` and `audit_log.details` encrypted with AES-256-GCM when `DATA_ENCRYPTION_KEY` is set
- **File uploads to S3** — CSV/JSON scenario files stored in S3; metadata in PostgreSQL
- **Health endpoint** — `GET /health` for container health checks; `GET /api/status` for vector store status
- **Single-origin deployment** — backend serves compiled frontend static files; no separate CDN or frontend server needed

---

## AI & Matching Pipeline

Each scenario submission runs through a **LangGraph workflow** with two nodes:

```
Input → [scenario_processor] → [orchestrator] → Result
```

### Node 1: scenario_processor
- Validates and normalises scenario name, description, and risk type
- Writes step log entry with timestamp

### Node 2: orchestrator
- **Historical matching** (3-tier, in priority order):
  1. **Groq embeddings** → stores in ChromaDB → cosine similarity query
  2. **HuggingFace sentence-transformers** → stores in ChromaDB → cosine similarity query
  3. **TF-IDF** (scikit-learn) → pure in-memory fallback, no external dependency
- **AI recommendations** — calls Groq `llama-3.1-8b-instant` with scenario context + top historical cases; returns 3–6 bullet-point controls

The matching tier used at runtime is visible via `GET /api/status`.

---

## Security

| Concern | Implementation |
|---|---|
| Authentication | JWT (HS256), configurable expiry |
| Authorisation | RBAC — admin-only endpoints for audit logs |
| Encryption at rest | AES-256-GCM on sensitive DB fields |
| Encryption in transit | HTTPS/TLS at reverse proxy / load balancer |
| Container security | Non-root user (`app`, UID 1000) inside Docker |
| Secret management | Environment variables via `.env`; never committed |
| File upload validation | Content-type allowlist, 5 MB size limit |
| CORS | Origin allowlist + regex; configured per environment |

---

## API Reference

| Method | Endpoint | Auth | Description |
|---|---|---|---|
| `POST` | `/login` | None | Email + password → JWT token |
| `GET` | `/health` | None | Service health check |
| `GET` | `/api/status` | User | Vector store / embedding backend status |
| `POST` | `/api/scenarios/input` | User | Submit a single scenario |
| `POST` | `/api/scenarios/upload` | User | Bulk upload CSV or JSON |
| `GET` | `/api/scenarios/recent` | User | Recent submissions (dashboard) |
| `GET` | `/api/scenarios/{id}/result` | User | Scenario result with recommendations |
| `GET` | `/api/scenarios/{id}/map` | User | Alias for `/result` |
| `GET` | `/api/historical-cases` | User | Reference case corpus (63 cases) |
| `GET` | `/api/audit/logs` | Admin | Audit log entries |
| `GET` | `/api/admin/audit-logs` | Admin | Audit log entries (alias) |

Interactive docs: `http://localhost:8000/docs`

---

## Project Structure

```
fin-scenario-map/
├── backend/
│   ├── main.py                  # FastAPI app, routes, static file serving
│   ├── models.py                # Pydantic request/response models
│   ├── db.py                    # PostgreSQL persistence (psycopg2)
│   ├── auth.py                  # JWT creation and verification
│   ├── users.py                 # RBAC user store
│   ├── settings.py              # Environment-based configuration
│   ├── encryption.py            # AES-256-GCM at rest
│   ├── historical_matcher.py    # 3-tier matching (Groq / HF / TF-IDF)
│   ├── embeddings.py            # Groq embedding API client
│   ├── embeddings_hf.py         # HuggingFace sentence-transformers
│   ├── chroma_store.py          # ChromaDB vector store
│   ├── recommendation_engine.py # Groq LLM recommendations
│   ├── s3_storage.py            # AWS S3 upload
│   ├── run_log.py               # Structured run logging
│   └── workflow/
│       ├── graph.py             # LangGraph graph definition
│       ├── nodes.py             # scenario_processor + orchestrator nodes
│       ├── runner.py            # Workflow entry point
│       └── state.py             # WorkflowState TypedDict
├── frontend/                    # React + TypeScript (Vite)
├── docs/
│   ├── deployment.md            # Deployment guide (Docker, AWS, HTTPS)
│   └── ENCRYPTION.md            # Encryption details (AES-256-GCM)
├── Dockerfile                   # Multi-stage build (Node → Python)
├── docker-compose.yml           # Backend + PostgreSQL + volumes
├── requirements.txt             # Python dependencies
└── .env.example                 # Environment variable template
```

---

## Local Development

### Prerequisites
- Python 3.11+
- Node.js 20+
- PostgreSQL 15+

### Backend

```bash
cp .env.example .env          # configure DATABASE_URL, JWT_SECRET_KEY, GROQ_API_KEY
pip install -r requirements.txt
uvicorn backend.main:app --reload
```

### Frontend

```bash
cd frontend
npm install
npm run dev
```

App runs at `http://localhost:5173` (dev) or `http://localhost:8000` (Docker).

---

## Deployment

See [docs/deployment.md](docs/deployment.md) for the full guide including:

- Docker quick start
- Production checklist (JWT secret, encryption key, managed DB, HTTPS)
- Cloud deployment (AWS ECS, GCP Cloud Run, Railway, etc.)
- HTTPS/TLS setup with reverse proxy

### Quick start (Docker)

```bash
cp .env.example .env
# edit .env: set JWT_SECRET_KEY, POSTGRES_PASSWORD, GROQ_API_KEY
docker compose up -d
```

App available at `http://localhost:8000` — API docs at `http://localhost:8000/docs`.

---

## Demo Credentials

| Email | Password | Role |
|---|---|---|
| `admin@example.com` | `adminpass` | Admin (audit logs access) |
| `test@example.com` | `password123` | User |
| `alice@example.com` | `alicepass` | User |
